2019-02-16
1、单例模式
   适用场景: 只需要一个实例的场景，每次获取到的实例都是一样的。
             如许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。
			 比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，
			 然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。
			 同时也适用于线程之间共享资源。需要注意的是如果单例对象长时间没有被使用会被回收。
			 
   实现思路: 私有构造，使外部不能创建其实例，使全局只有一个实例，有一个返回唯一实例的静态方法。
   
   懒加载单例和饿单例的区别，懒加载单例在多线程情况下会有线程安全问题(创建两个实例)，饿单例不会。
   

2019-02-17
2、简单工厂模式
   适用场景: 有一系列的类型，如果每个类型都是直接new，那么当类型改变时，需要修改散落在系统的所有地方
             如果使用工厂模式，让工厂创建需要的类型，那么当需要修改时只需要修改工厂类中代码即可。
			 
   实现思路: 抽象产品类，会有各种系列的产品(颜色、大小等)的实现类，如何使用这些系列的某种产品，
             一种方法是直接new对应的系列实例，但是这样当需要修改时，将要在所有地方修改对应的实例，如要把红色修改为深红色实例
			 那么就需要找到new红色实例的地方然后一一修改为深红色实例；而如果使用工厂模式，只需要修改工厂类中创建实例的方法即可。
			 
   简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。

2019-02-21
3、适配器模式
   适用场景：已存在对象的接口不是需要的接口，把已存在的对象的接口适配为需要的接口，以复用存在的方法。
   实现思路：已存在一个能和电脑交换数据的2.0的usb接口，现在需要一个3.0的usb既能实现和电脑交换数据也能实现和手机交换数据，
             那么就需要使用适配器模式，把3.0usb接口适配为2.0usb接口。这样在使用3.0接口操作时不用创建2.0的usb实例。达到复用的目的。
			 
			 
2019-02-23
4、模板方法模式
   适用场景：具有固定处理流程的处理逻辑，不管具体实现类如何实现这些流程。
   实现思路：一个产品，首先要生产，然后是注册，最后才能使用，也就是说，生成-->注册的流程是固定的。
       
2019-02-27
5、工厂方法设计模式
   适用场景：有许多不同类型的实例，需要把实例的生成交给工厂类。
   实现思路：针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。如有各种颜色的产品，创建不同颜色的工厂用于生成不同的产品。

2019-02-28
6、装饰器设计模式
   适用场景：不可继承的类，想拥有类的默认行为，又想扩展某系自己的行为
   实现思路；通过组合，拥有原有类的实例，并扩展自己的方法行为。   
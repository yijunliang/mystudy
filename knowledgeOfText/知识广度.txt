学习顺序：1、每天积累一个新的知识点，不需要深入了解，需要知道它是做什么的在什么场景下使用就行。并完善之前积累的知识(重复查、看)。
          2、需要深入了解spring cloud 的各个组件 --> 分布式事务 --> 事务 --> 消息中间件 --> 线程，线程池 --> 缓存(redis等) --> jvm --> 日志

1、spring cloud是什么，适用于什么场景
   1>是http协议传输，带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更大
   2>接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级
   3>注册中心只能用eureka或者自研
   4>Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，
     提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、
	 一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案
   5>dubbo是spring cloud的一个子集
   6>spring cloud是一套完整的分布式系统解决方案，它的子项目涵盖了所有实现布式系统所需要的基础软件设施


2、dubbo又是什么
   1>是二进制的传输，占用带宽会更少
   2>注册中心可以选择zk,redis等多种，springcloud的注册中心只能用eureka或者自研
   3>对于类似于电商等同步调用场景多并且能支撑搭建Dubbo 这套比较复杂环境的成本的产品而言，
     Dubbo 确实是一个可以考虑的选择。但如果产品业务中由于后台业务逻辑复杂、时间长而导致异步逻辑比较多的话，
	 可能Dubbo 并不合适。同时，对于人手不足的初创产品而言，这么重的架构维护起来也不是很方便
	 
3、单体应用和spring cloud微服务应用的区别是什么，在什么情况下选择微服务，什么情况下选择单体应用
   1>单体应用中，如果需要改动功能，那么则需要重新部署整个单体应用。
     而微服务则不需要，只需要重新部署修改的功能模块那个微服务。
	 每一个功能模块都是可独立替换和独立维护的软件单元，完全体现了高可复用性，高可维护性，高可扩展性。
   2>单体应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩
   3>单体应用的复杂性高，所有模块的代码都在一起，模块间边界模糊，代码质量参差不齐
	 
3、redis是什么，适用场景又是什么，redis集群搭建
   1>redis键值型数据库(NOSQL),读写速度非常快，大概每秒10万的读写速度。
   2>适用于需要频繁访问的热点数据的存储(如果某个页面会频繁打开,查询条件有规律而且查询数据量大速度慢可以考虑使用redis做缓存)
   3>数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上
   4>网络IO模型方面：Redis使用单线程的IO复用模型，将速度优势发挥到最大，也提供了较简单的计算功能。
   5>Redis使用现场申请内存的方式来存储数据，不会剔除任何非临时数据 Redis更适合作为存储而不是cache。
     Redis提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断 
   6>快速的主--从复制
   7>Sharding技术：很容易将数据分布到多个Redis实例中(数据库扩展)，负载分布到多个物理节点上去的横向扩展方式用处越来越多。
     扩展redis数据库很方便。
   8>redis也可以用于消息队列，但是入队时，如果数据大小超过了10K，Redis则会很慢；
	 
4、kafka是什么，适用场景有哪些
   1>kafka是一个分布式消息系统，它以可水平扩展和高吞吐率而被广泛使用
   2>为什么要使用消息系统:
     1)解耦
       在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。
	   消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。
	   这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束
	 2)冗余
	   有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。
	   消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。
	   许多消息队列所采用的"插入-获取-删除"范式中，在把一个消息从队列中删除之前，
	   需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。
	 3)扩展性
       因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。
	   不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单
	 4)灵活性 & 峰值处理能力
       在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；
	   如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。
	   使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。
	 5)可恢复性
       系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，
	   所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。
	 6)顺序保证
       在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，
	   并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。
	 7)缓冲
       在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。
	   消息队列通过一个缓冲层来帮助任务最高效率的执行―――写入队列的处理会尽可能的快速。
	   该缓冲有助于控制和优化数据流经过系统的速度。
	 8)异步通信
       很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，
	   但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。
	3>使用kafka当做消息队列，比如数据入库，每天9点终端采集数据发送到前置，前置把数据放入kafka,入库程序从kafka取出数据持久化到数据库。
	  扩展(数据量大时导出应用kafka):使用线程池分页查询大数据量数据，每页数据存入kafka，从kafka中取出每页数据写到Excel表格中，消费完kafka中数据
	  整个导出功能就完成。这里导出涉及到查询-->写入kafka-->从kafka取出数据-->写入excel文件。
	4>适用于发布--订阅模式的场景，比如n个用户订阅A主题,A主题更新之后会推送到所有订阅它的用户，各个用户根据订阅到的消息做逻辑处理。
	  如用户浏览时发布浏览记录--->订阅者拿到用户的浏览记录之后就可以向用户推送相关主题信息。
   5>日志收集
	
5、zookeeper是什么？使用场景是什么？
   1>zookeeper是一个为分布式应用提供一致性服务的软件
     用于配置管理，代码中引入配置文件的方式适用于只有一种配置、一台服务器、不经常修改的情况。
     如果有多个不同的配置，多台服务器都需要这些配置，并且可能是动态的配置那么就需要对配置进行集中管理。
	 也就是，集中管理的配置发生了改变，其它所有对配置感兴趣的都可以获得变更。zookeeper维护了集群间的一致性。
   2>zookeeper提供了分布式锁
   
6、nginx是什么?适用场景是什么？
   1>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，占有内存少，并发能力强。
   2>可以使用nginx当静态文件服务器。
   3>nginx可以实现tomcat等的集群。
   4>nginx的原理是通过监听80端口，把请求根据规则(负载均衡)转发到实际服务器。
   5>反向代理服务器简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，
     而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。
	 也就是请求-->nginx-->真实服务器-->返回结果-->nginx-->请求客户端。
   6>nginx可以实现请求的负载均衡，默认使用轮询方式其它方式还有权重、ip_hash(每个访客固定访问一个后端服务器,解决session问题)、
     fair(第三方，按后端服务器的响应时间来分配请求，响应时间短的优先分配)、
	 url_hash(第三方，按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效)
   7>nginx可以对网页做动静分离，即让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，然后对静态资源做缓存。

7、jetty是什么？适用场景是什么？
   1>jetty和tomcat一样是webserver/servlet容器，但是jetty比tomcat更轻量级(去除了一些企业级应用的特性)
   2>企业级应用使用tomcat更优
   3>jetty更满足公有云的分布式环境的需求
   4>jetty默认采用NIO结束在处理I/O请求上更占优势，在处理静态资源时，性能较高
   5>Tomcat默认采用BIO处理I/O请求，在处理静态资源时，性能较差。
   
   
8、多线程、线程池、连接池

9、分布式事务，分布式难点解决方案
   1>基于XA协议的两阶段提交方案
   2>补偿事务TCC方案
   3>本地消息表（异步确保）
   4>MQ事务消息

10、NOSQL是什么？适用场景是什么？原理是什么？
    1>泛指非关系型数据库，主要有四大类
	  1)键值(Key-Value)存储数据库:这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。如redis。
	  2)列存储数据库:键指向多个列，用来应对分布式存储的海量数据。如 HBase。
	  3)文档型数据库:数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。是键值数据库的升级版，允许之间嵌套键值。如MongoDb。
	  4)图形(Graph)数据库:图结构,如Infinite Graph。

11、spring 技术栈

12、搭建一个大型分布式系统需要用到的组件有什么?各个组件分别充当什么作用？

13、集群用于解决什么问题？分布式又用于解决什么问题？分布式集群又用于解决什么问题？

14、NIO适用场景是什么？和IO的区别是什么？
    1>IO面向流，是阻塞的。NIO面向缓冲，是非阻塞的。
	2>IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。它不能前后移动流中的数据。
	3>NIO数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。
	4>IO是阻塞的，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。
	5>NIO是非阻塞的，有数据就读取，没有数据就干别的事情。
	6>IO适合少量连接使用非常高的带宽，一次发送大量数据的情况。

15、jvm调优


16、不同种类的消息中间件的区别,消息队列的作用，各种消息中间件的使用场景
    1>消息中间件是一个中间层，它协调各个系统的通信，如A发出指令-->消息中间件-->B接收指令，做出相应行为。
	2>消息中间件能在不同平台之间通信，它常被用来屏蔽掉各种平台及协议之间的特性，实现应用程序之间的协同，
	  其优点在于能够在客户和服务器之间提供同步和异步的连接，并且在任何时刻都可以将消息进行传送或者存储转发，
	  这也是它比远程过程调用更进一步的原因。
	3>ActiveMQ：
	4>RabbitMQ:
	5>RocketMQ:
	6>Kafka:
	7>广泛来说，电商、金融 等对 事务一致性 要求很高的，可以考虑 RabbitMQ 和 RocketMQ，对 性能要求高 的可考虑 Kafka。
	

17、什么是rpc
    1>rpc是远程过程调用，也就是说两台服务器A,B, 一个应用部署在A服务器上，另一个应用部署在B服务器上，
	  A服务器上的应用想要调用B服务器上的应用提供的方法/函数，由于不在一个内存空间，不能直接调用，
	  需要通过网络来表达调用的语意和传递调用的参数。
	2>过程:建立TCP连接-->寻址的问题(需要得到B服务器地址)-->要传输的消息序列化发送给B服务器-->B接收到请求，对接收的数据进行反序列化，
	       恢复为内存调用，得到返回结果-->返回结果序列化传输给调用方A服务器-->A接收到返回数据，反序列化然后使用。

18、git/svn版本控制

19、目前系统使用到的组件、技术、架构
    终端采集数据-->发送到前置，前置把数据存入kafka集群(zookeeper协调kafka集群)-->入库程序从kafka集群中消费数据(读取)，写入数据库
	-->计量主站系统从数据库中读取数据，进行页面展示、数据分析等等
	
2019-04-08，Docker是什么
    1、Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，
	   然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。
	2、Docker可以用于Web 应用的自动化打包和发布
	3、Docker可以用于自动化测试和持续集成、发布
	4、Docker可以用于在服务型环境中部署和调整数据库或其他的后台应用
	5、Docker可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、
	   消息队列等等都可以打包成一个镜像部署
	6、Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式
	7、Docker通俗地说就是一个容器，我们可以在这个容器中存放自己的一些安装应用程序，然后打包快速地在新环境中安装这些环境。
    
  

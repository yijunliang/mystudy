1、字符串是不可变类型，当参数传递时是按值传递
   也就是说把字符串当参数传递时修改参数不会改变原来的字符串
   
2、基本数据类型和字符串是按值传递（对参数的修改不会影响原数据），数组和对象类型是按引用传递（对参数的修改会改变原数据）。
   
   基本数据类型的包装类和数组以及对象是按引用传递（对参数的修改会影响原数据）
   但是如果fun(Person p1) { p = new Person(); }这样的话，参数的改变不会影响原数据，此时
   p的引用指向的是一个全新的对象


3、原码:数字的二进制数

   正数的补码:等于它本身的原码

   负数的补码:符号位不变，其余各位取反，末位+1
   
   正数反码:等于它本身的原码
   
   负数的反码:原码的符号位不变，其余各位取反
   
4、Java内存划分:
   栈区:由编译器自动分配释放,存放函数的参数值，局部变量的值等，具体方法执行结束之后，
        系统自动释放JVM内存资源

   堆区:存放由new创建的对象和数组，又划分为两块

        Perm区（持久代）:存放静态数据类型如Java类的.class文件等，内存溢出的原因:动态加载了大量Java类

        Heap区(年老代):分两块，内存溢出原因:循环上万次的字符串处理、不断创建对象、申请过大的内存

               Old区:每次GC的时候，存活下来的对象首先由Eden拷贝到某个SurvivorSpace(From区和To区),
                     当SurvivorSpace(From区和To区)空间满了后,
                     剩下的live对象就被直接拷贝到OldGeneration(old区)中去
               New区:分为
                 Eden区:主要是用来存放新生的对象
                 From区和To区:存放每次垃圾回收后存活下来的对象
                

   方法区(代码区):存放程序中方法的二进制代码，而且是多个对象共享一个代码空间区域，
                  即各线程共享的内存区域。也是常量池所在，
                  常量池存放基本类型、String等（常量池存在于堆中）
               
               
5、集合中线程安全的有
   Vector
   HashTable
   Stack
   enumeration
   其他的都是线程不安全的。
   
   
6、访问权限
    private                 本类
    defaulet                本包在不同包的子类不能访问
    protected               子类
    public                  全局
               
7、Java8新特性
   接口中可以定义默认方法
   接口中可以定义静态方法       
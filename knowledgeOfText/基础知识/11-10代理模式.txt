1、静态代理(代码实现)
   1>接口类中定义有添加用户删除用户的方法
   2>接口的实现类实现添加和删除方法(目标类)
   3>建一个代理类要实现与目标类相同的接口，并且代理类中有自己的方法(如写日志等)
     并且定义目标类实现的接口对象，通过接口对象调用接口方法
   4>当要写日志的时候new的是代理类的实例，不用写日志的时候new的是目标类的实例


2、动态代理(代码实现)
   1>接口类中定义有添加用户删除用户的方法
   2>接口的实现类实现添加和删除方法(目标类)
   3>代理类定义有Object类对象（目标类的实例），实现InvocationHandler接口
     并且有返回目标类实例的方法(通过Proxy.newProxyInstance()返回)
     这个方法的参数要传的是目标类对象。在invoke方法中
     Object ret = method.invoke(target, args);//反射生成一个目标类对象
     log();//调用写日志方法
     return ret;
   4>当要写日志的时候new的是代理类的实例调用创建目标类的方法(new一个目标类对象当参数)，
     不用写日志的时候new的是目标类的实例。
     这样做的好处就是代理类不需要实现指定接口，当想换目标类时只需要传不同的目标类对象就可以了
     
   